# Nazim Web Frontend i18n (Translations) — Enforcement & Tooling

## Current structure (discovered)

- **Runtime translation function**: `frontend/src/lib/i18n.ts` exports `t(key, lang, params)`
  - **Where keys come from**: dot-path strings used throughout the frontend, e.g. `academic.academicYears.title`
  - **How translations are imported**: `i18n.ts` imports and re-exports a `translations` dictionary:
    - `frontend/src/lib/translations/en.ts` → `export const en`
    - `frontend/src/lib/translations/ps.ts` → `export const ps`
    - `frontend/src/lib/translations/fa.ts` → `export const fa`
    - `frontend/src/lib/translations/ar.ts` → `export const ar`
  - **How missing keys behaved historically**:
    - If missing in requested language → fall back to **English**
    - If missing in English too → return a **humanized last segment** (e.g. `nav.dashboard` → `Dashboard`)
- **React hook**: `frontend/src/hooks/useLanguage.tsx`
  - Provides `t()` bound to the current language
  - Sets `dir` and `lang` attributes on `<html>` and applies RTL/LTR body classes/fonts

## Strict missing-key mode (DEV/TEST)

Goal: **Missing keys must be obvious during development and tests** (no silent fallback).

### How it works

`frontend/src/lib/i18n.ts` now supports a strict mode:
- If a key is missing in both the current language and English:
  - **Strict mode**: returns **`[MISSING: some.key]`** and `console.warn`s **once per key** (deduped)
  - **Production mode**: preserves existing behavior (humanize last segment)

### How to enable

In Vite:
- Set `VITE_I18N_STRICT=true`

By default, strict mode is also enabled in:
- Vite `DEV`
- `MODE === 'test'`

## “What needs translation” coverage report

### What it generates

Script: `frontend/scripts/i18n/translation-coverage.ts`

Outputs **in the repo root**:
- `translation-coverage.md` (human-readable)
- `translation-coverage.json` (machine-readable)

It reports:
- Keys present in **EN** but missing in **PS/FA/AR**
- Optional drift: keys present in PS/FA/AR but not in EN
- Keys **used in code** (scans `frontend/src` for `t('...')`) and which of those are missing per language
- Top 20 namespaces with missing used keys (`dms.*`, `exams.*`, etc.)
- Top files with most missing-used keys

### Run it

From `frontend/`:

```bash
npm run i18n:coverage
```

CI mode (incremental):

```bash
npm run i18n:coverage:ci
```

`i18n:coverage:ci` will fail if **missing used keys** exceeds:
- `I18N_COVERAGE_CI_MAX_MISSING_USED` (absolute cap), OR
- `frontend/scripts/i18n/coverage.baseline.json` (baseline cap), OR
- `0` if no baseline exists

To (re)generate the baseline intentionally:

```bash
tsx scripts/i18n/translation-coverage.ts --update-baseline
```

## Preventing new translation debt (CI-friendly)

Script: `frontend/scripts/i18n/check-bad-patterns.js`

It checks `frontend/src` for:
- **A)** `t('...') || 'English'` (fallback strings after t())
- **B)** `showToast.success('Hardcoded')` (hardcoded toast messages)
  - Translation-key literals like `showToast.success('toast.userCreated')` are allowed (contains a dot)

### Run it

```bash
npm run i18n:check
```

This is **baseline-based** (incremental enforcement):
- It fails if totals or per-file counts increase vs `frontend/scripts/i18n/bad-patterns.baseline.json`
- Update baseline intentionally with:

```bash
npm run i18n:check:update-baseline
```

## Type-safe translation keys (fast, flat union)

Goal: autocomplete + compile-time safety for `t('...')` without recursive TS types.

Generator: `frontend/scripts/i18n/generate-translation-keys.ts`

Output (committed):
- `frontend/src/lib/translations/keys.generated.ts`
  - `export const TRANSLATION_KEYS = [...] as const;`
  - `export type TranslationKey = typeof TRANSLATION_KEYS[number];`

Regenerate:

```bash
npm run i18n:keys:generate
```


